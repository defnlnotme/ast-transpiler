import { BaseTranspiler } from "./baseTranspiler.js";
import { regexAll } from "./utils.js";
import ts from 'typescript';

const SyntaxKind = ts.SyntaxKind;

const parserConfig = {
    'STATIC_TOKEN': '', // to do static decorator
    'PUBLIC_KEYWORD': '',
    'UNDEFINED_TOKEN': "nothing",
    'IF_TOKEN': "if",
    'ELSE_TOKEN': "else",
    'ELSEIF_TOKEN': "elseif",
    'THIS_TOKEN': "self", // Julia uses 'this' differently; adjust as needed
    'AMPERSTAND_APERSAND_TOKEN': "&&",
    'BAR_BAR_TOKEN': "||",
    'SPACE_DEFAULT_PARAM': "",
    'BLOCK_OPENING_TOKEN': "",
    'BLOCK_CLOSING_TOKEN': "end",
    'SPACE_BEFORE_BLOCK_OPENING': "",
    'CONDITION_OPENING': "",
    'CONDITION_CLOSE': "",
    'TRUE_KEYWORD': "true",
    'FALSE_KEYWORD': "false",
    'THROW_TOKEN': "throw",
    'NOT_TOKEN': "!",
    'PLUS_PLUS_TOKEN': " += 1",
    'MINUS_MINUS_TOKEN': " -= 1",
    'SUPER_CALL_TOKEN': "super()",
    'PROPERTY_ASSIGNMENT_TOKEN': "=",
    'FUNCTION_TOKEN': "function",
    'SUPER_TOKEN': "super()",
    'NEW_TOKEN': "new",
    'STRING_QUOTE_TOKEN': '"',
    'LINE_TERMINATOR': ";",
    'METHOD_TOKEN': "function",
    'CATCH_TOKEN': "catch",
    'CATCH_DECLARATION': "e",
    'METHOD_DEFAULT_ACCESS': "",
    'SPREAD_TOKEN': "...",
    'NULL_TOKEN': "nothing",
};

export class JuliaTranspiler extends BaseTranspiler {
    constructor(config = {}) {
        config['parser'] = Object.assign({}, parserConfig, config['parser'] ?? {});

        super(config);
        this.id = "julia";

        this.initConfig();
        this.asyncTranspiling = config['async'] ?? true;
        // Remove this line since it's overriding the config
        // this.uncamelcaseIdentifiers = config['uncamelcaseIdentifiers'] ?? true;

        // The uncamelcaseIdentifiers option is already set in BaseTranspiler constructor
        // with a default value of false, so we don't need to set it here unless
        // specifically provided in config

        this.removeVariableDeclarationForFunctionExpression = config['removeVariableDeclarationForFunctionExpression'] ?? true;
        this.includeFunctionNameInFunctionExpressionDeclaration = config['includeFunctionNameInFunctionExpressionDeclaration'] ?? true;

        // User overrides
        this.applyUserOverrides(config);
    }

    initConfig() {
        this.LeftPropertyAccessReplacements = {
            'this': "self"
        };
        this.RightPropertyAccessReplacements = {
            'push': "push!",
            'toUpperCase': "uppercase",
            'toLowerCase': "lowercase",
            'indexOf': "findfirst",
            'padEnd': "rpad",
            'padStart': "lpad"
        };
        this.FullPropertyAccessReplacements = {
            'console.log': "println",
            'JSON.stringify': "JSON3.json",
            'JSON.parse': "JSON3.parse",
            'Math.log': "log",
            'Math.abs': "abs",
            'Math.min': "minimum",
            'Math.max': "maximum",
            'Math.ceil': "ceil",
            'Math.round': "round",
            'Math.floor': "floor",
            'Math.pow': "pow",
            'process.exit': "exit",
            'Number.MAX_SAFE_INTEGER': "typemax(Int)",
        };
        this.CallExpressionReplacements = {
            'parseInt': "parse(Int, ",
            'parseFloat': "parse(Float64, ",
        };
        this.PropertyAccessRequiresParenthesisRemoval = [
            // Adjust as needed for Julia
        ];
    }

    printNode(node: ts.Node, identation: number): string {
        // Handle source file with comments
        if (ts.isSourceFile(node)) {
            const fullText = node.getFullText();
            const comments: string[] = [];

            // Get standalone comments at the start of the file
            const triviaComments = ts.getLeadingCommentRanges(fullText, 0);
            if (triviaComments) {
                triviaComments.forEach(commentRange => {
                    const commentText = fullText.slice(commentRange.pos, commentRange.end).trim();
                    if (commentText.startsWith('//')) {
                        comments.push('# ' + commentText.slice(2).trim());
                    } else if (commentText.startsWith('/*')) {
                        const multilineComment = commentText.slice(2, -2).trim();
                        // Add space after #=
                        comments.push('#= ' + multilineComment + ' =#');
                    }
                });
            }

            // Return comments with proper formatting
            return comments.join('\n').trim();
        }

        return super.printNode(node, identation);
    }

    printArrayIsArrayCall(node, identation, parsedArg = undefined) {
        return `isa(${parsedArg}, AbstractArray)`;
    }

    printObjectKeysCall(node, identation, parsedArg = undefined) {
        return `keys(${parsedArg})`;
    }

    printObjectValuesCall(node, identation, parsedArg = undefined) {
        return `values(${parsedArg})`;
    }

    printPromiseAllCall(node, identation, parsedArg) {
        return `asyncmap(${parsedArg})`; // Julia's asynchronous programming differs
    }

    printMathFloorCall(node, identation, parsedArg = undefined) {
        return `floor(Int, ${parsedArg})`;
    }

    printMathCeilCall(node, identation, parsedArg = undefined) {
        return `ceil(Int, ${parsedArg})`;
    }

    printNumberIsIntegerCall(node, identation, parsedArg = undefined) {
        return `isa(${parsedArg}, Integer)`;
    }

    printMathRoundCall(node, identation, parsedArg = undefined) {
        return `round(Int, ${parsedArg})`;
    }

    printIncludesCall(node, identation, name?, parsedArg?) {
        return `in(${parsedArg}, ${name})`;
    }

    printJoinCall(node, identation, name?, parsedArg?) {
        return `join(${name}, ${parsedArg})`;
    }

    printSplitCall(node, identation, name?, parsedArg?) {
        return `split(${name}, ${parsedArg})`;
    }

    printConcatCall(node, identation, name?, parsedArg?) {
        return `[${name}; ${parsedArg}]`; // Concatenate arrays
    }

    printPopCall(node, identation, name) {
        return `pop!(${name})`;
    }

    printShiftCall(node, identation, name) {
        return `shift!(${name})`;
    }

    printReverseCall(node, identation, name = undefined) {
        return `reverse!(${name})`;
    }

    printArrayPushCall(node, identation, name, parsedArg) {
        return `push!(${name}, ${parsedArg})`;
    }

    printToStringCall(node, identation, name = undefined) {
        return `string(${name})`;
    }

    printIndexOfCall(node, identation, name = undefined, parsedArg = undefined) {
        return `findfirst(${parsedArg}, ${name})`;
    }

    printSearchCall(node, identation, name = undefined, parsedArg = undefined) {
        return `findfirst(${parsedArg}, ${name})`;
    }

    printStartsWithCall(node, identation, name = undefined, parsedArg = undefined) {
        return `startswith(${name}, ${parsedArg})`;
    }

    printEndsWithCall(node, identation, name = undefined, parsedArg = undefined) {
        return `endswith(${name}, ${parsedArg})`;
    }

    printPadEndCall(node, identation, name, parsedArg, parsedArg2) {
        return `rpad(${name}, ${parsedArg}, ${parsedArg2})`;
    }

    printPadStartCall(node, identation, name, parsedArg, parsedArg2) {
        return `lpad(${name}, ${parsedArg}, ${parsedArg2})`;
    }

    printTrimCall(node, identation, name = undefined) {
        return `strip(${name})`;
    }

    printToUpperCaseCall(node, identation, name = undefined) {
        return `uppercase(${name})`;
    }

    printToLowerCaseCall(node, identation, name = undefined) {
        return `lowercase(${name})`;
    }

    printJsonParseCall(node, identation, parsedArg = undefined) {
        return `JSON3.parse(${parsedArg})`;
    }

    printJsonStringifyCall(node, identation, parsedArg = undefined) {
        return `JSON3.json(${parsedArg})`;
    }

    printReplaceCall(node, identation, name?, parsedArg?, parsedArg2?) {
        return `replace(${name}, ${parsedArg} => ${parsedArg2})`;
    }

    printReplaceAllCall(node, identation, name?, parsedArg?, parsedArg2?) {
        return `replace(${name}, r"${parsedArg}" => "${parsedArg2}")`;
    }

    printElementAccessExpressionExceptionIfAny(node) {
        if (node.expression.kind === SyntaxKind.ThisKeyword) {
            return "getfield(self, $(Expr(:quote, $(this.printNode(node.argumentExpression, 0))))))";
        }
    }

    printAssertCall(node, identation, parsedArgs) {
        return `@assert ${parsedArgs}`;
    }

    printDateNowCall(node, identation) {
        return "Int(time())";
    }

    printForStatement(node: ts.ForStatement, identation: number): string {
        let varName: string;
        let initValue: string;

        // Check initializer
        if (node.initializer && ts.isVariableDeclarationList(node.initializer)) {
            varName = node.initializer.declarations[0].name.getText();
            initValue = this.printNode(node.initializer.declarations[0].initializer, 0);
        } else {
            throw new Error("Unsupported for loop initializer");
        }

        // Check condition
        let endValue: string;
        if (node.condition && ts.isBinaryExpression(node.condition)) {
            if (ts.isNumericLiteral(node.condition.right)) {
                const numValue = parseInt(node.condition.right.text);
                endValue = (numValue - 1).toString();
            } else {
                endValue = this.printNode(node.condition.right, 0);
            }
        } else {
            throw new Error("Unsupported for loop condition");
        }

        // Check statement block
        let statements = "";
        if (node.statement && ts.isBlock(node.statement)) {
            statements = node.statement.statements
                .map(st => this.getIden(identation + 1) + this.printNode(st, 0))
                .join("\n");
        } else {
            throw new Error("Unsupported for loop statement block");
        }

        const forStm = this.getIden(identation) +
            this.FOR_TOKEN + " " +
            varName + " in " +
            initValue + ":" + endValue + "\n" +
            statements +
            "\n" + this.getIden(identation) + "end";

        return this.printNodeCommentsIfAny(node, identation, forStm);
    }

    printPropertyAccessModifiers(node) {
        return ""; // No access modifiers in Julia
    }

    transformPropertyAcessExpressionIfNeeded(node) {
        const expression = node.expression;
        const leftSide = this.printNode(expression, 0);
        const rightSide = node.name.escapedText;

        let rawExpression = undefined;

        if (rightSide === "length") {
            rawExpression = "length($leftSide)";
        } else if (rightSide === "toString") {
            rawExpression = "string($leftSide)";
        }
        return rawExpression;
    }
    printConstructorDeclaration(node, identation) {
        // Julia doesn't use explicit constructors inside structs
        return "";
    }

    printClassDefinition(node, identation) {
        const className = node.name.escapedText;
        const heritageClauses = node.heritageClauses;

        let classInit = "";
        if (heritageClauses !== undefined) {
            const classExtends = heritageClauses[0].types[0].expression.escapedText;
            classInit = this.getIden(identation) + "struct " + className + " <: " + classExtends + "\n";
        } else {
            classInit = this.getIden(identation) + "struct " + className + "\n";
        }
        return classInit;
    }

    printClassBody(node, identation) {
        // Extract property declarations from constructor and class body
        const properties = new Set<string>();

        // Find constructor
        const constructorNode = node.members.find(m => m.kind === ts.SyntaxKind.Constructor);

        // Get properties from constructor assignments
        if (constructorNode) {
            constructorNode.body?.statements.forEach(stmt => {
                if (ts.isExpressionStatement(stmt)) {
                    const expr = stmt.expression;
                    if (ts.isBinaryExpression(expr) &&
                        expr.operatorToken.kind === ts.SyntaxKind.EqualsToken &&
                        ts.isPropertyAccessExpression(expr.left) &&
                        expr.left.expression.kind === ts.SyntaxKind.ThisKeyword) {
                        properties.add(expr.left.name.escapedText.toString());
                    }
                }
            });
        }

        // Get properties from class property declarations
        node.members.forEach(member => {
            if (ts.isPropertyDeclaration(member)) {
                const propName = member.name.getText();
                properties.add(propName);
            }
        });

        // Build property declarations
        const propertyDeclarations = Array.from(properties)
            .map(prop => `${this.getIden(identation)}${prop}`)
            .join('\n');

        return propertyDeclarations;
    }

    printClass(node, identation) {
        const classDefinition = this.printClassDefinition(node, identation);
        const classBody = this.printClassBody(node, identation + 1);
        return classDefinition + classBody + "\n" + this.getIden(identation) + "end";
    }

    printPropertyDeclaration(node, identation) {
        // Property declarations are handled in printClassBody
        return "";
    }
    printMethodParameters(node) {
        let parsedArgs = super.printMethodParameters(node);
        parsedArgs = parsedArgs ? "self, " + parsedArgs : "self";
        return parsedArgs;
    }

    printInstanceOfExpression(node, identation) {
        const left = this.printNode(node.left, 0);
        const right = this.printNode(node.right, 0);
        return this.getIden(identation) + `isa(${left}, ${right})`;
    }

    handleTypeOfInsideBinaryExpression(node, identation) {
        const expression = node.left.expression;
        const right = node.right.text;

        const op = node.operatorToken.kind;
        const isDifferentOperator = op === SyntaxKind.ExclamationEqualsEqualsToken || op === SyntaxKind.ExclamationEqualsToken;
        const notOperator = isDifferentOperator ? "!" : "";

        switch (right) {
        case "string":
            return this.getIden(identation) + notOperator + "isa(" + this.printNode(expression, 0) + ", AbstractString)";
        case "number":
            return this.getIden(identation) + notOperator + "isa(" + this.printNode(expression, 0) + ", Number)";
        case "boolean":
            return this.getIden(identation) + notOperator + "isa(" + this.printNode(expression, 0) + ", Bool)";
        case "object":
            return this.getIden(identation) + notOperator + "isa(" + this.printNode(expression, 0) + ", Dict)";
        case "undefined":
            return this.getIden(identation) + this.printNode(expression, 0) + " === " + notOperator + "nothing";
        }

        return undefined;
    }

    printCustomBinaryExpressionIfAny(node, identation) {
        const left = node.left;
        const right = node.right.text;

        const op = node.operatorToken.kind;

        // Fix comparisons like if cond == true -> if cond
        if ((op === ts.SyntaxKind.EqualsEqualsToken || op === ts.SyntaxKind.EqualsEqualsEqualsToken) && node.right.kind === ts.SyntaxKind.TrueKeyword) {
            return this.getIden(identation) + this.printNode(node.left, 0);
        }

        if (left.kind === ts.SyntaxKind.TypeOfExpression) {
            const typeOfExpression = this.handleTypeOfInsideBinaryExpression(node, identation);
            if (typeOfExpression) {
                return typeOfExpression;
            }
        }

        const prop = node?.left?.expression?.name?.text;

        if (prop) {
            const args = left.arguments;
            const parsedArg = (args && args.length > 0) ? this.printNode(args[0], 0) : undefined;
            const leftSideOfIndexOf = left.expression.expression;  // myString in myString.indexOf
            const leftSide = this.printNode(leftSideOfIndexOf, 0);

            switch (prop) {
            case 'indexOf':
                if (op === ts.SyntaxKind.GreaterThanEqualsToken && right === '0') {
                    return this.getIden(identation) + `in(${parsedArg}, ${leftSide})`;
                }
            }
        }
        return undefined;
    }

    printConditionalExpression(node, identation) {
        const condition = this.printNode(node.condition, 0);
        const whenTrue = this.printNode(node.whenTrue, 0);
        const whenFalse = this.printNode(node.whenFalse, 0);

        return this.getIden(identation) + whenTrue + " ? " + whenFalse + " : " + whenTrue;
    }

    printDeleteExpression(node, identation) {
        const expression = this.printNode(node.expression, 0);
        return `delete!(${expression})`;
    }

    getCustomOperatorIfAny(left, right, operator) {
        const rightText = right.getText();
        const isUndefined = rightText === "undefined";
        if (isUndefined) {
            switch (operator.kind) {
            case ts.SyntaxKind.EqualsEqualsToken:
                return "===";
            case ts.SyntaxKind.ExclamationEqualsToken:
                return "!==";
            case ts.SyntaxKind.ExclamationEqualsEqualsToken:
                return "!==";
            case ts.SyntaxKind.EqualsEqualsEqualsToken:
                return "===";
            }
        }
    }
    printTryStatement(node: ts.TryStatement, identation: number): string {
        // Get the try block statements
        const tryStatements = node.tryBlock.statements
            .map(stmt => this.getIden(identation + 1) + this.printNode(stmt, 0))
            .join('\n');

        // Get the catch block statements
        const catchStatements = node.catchClause.block.statements
            .map(stmt => this.getIden(identation + 1) + this.printNode(stmt, 0))
            .join('\n');

        const catchVariable = node.catchClause.variableDeclaration ?
            this.printNode(node.catchClause.variableDeclaration.name, 0) :
            'e';

        return this.getIden(identation) + "try\n" +
               tryStatements + "\n" +
               this.getIden(identation) + "catch " + catchVariable + "\n" +
               catchStatements + "\n" +
               this.getIden(identation) + "end";
    }

    transformLeadingComment(comment: string): string {
        if (comment.startsWith('//')) {
            return '# ' + comment.slice(2).trim();
        }

        if (comment.startsWith('/*')) {
            // Add space after #= and before =#
            return '#= ' + comment.slice(2, -2).trim() + ' =#';
        }

        return comment;
    }

    transformTrailingComment(comment: string): string {
        const commentRegex = [
            [/\/\//g, '#'],  // Single line comments
        ];

        return regexAll(comment, commentRegex);
    }

    printLeadingComments(node: ts.Node, identation: number): string {
        const fullText = global.src.getFullText();
        const commentsRangeList = ts.getLeadingCommentRanges(fullText, node.pos);
        const commentsRange = commentsRangeList ? commentsRangeList : undefined;
        let res = "";
        if (commentsRange) {
            for (const commentRange of commentsRange) {
                const commentText = fullText.slice(commentRange.pos, commentRange.end);
                if (commentText !== undefined) {
                    const transformed = this.transformLeadingComment(commentText.trim());
                    res += transformed + "\n";
                }
            }
        }
        return res;
    }
}